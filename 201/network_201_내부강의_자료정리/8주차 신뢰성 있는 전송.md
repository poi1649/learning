
#### 신뢰성 있는 전송 on 신뢰성 없는 채널
신뢰성 없는 채널의 특성에 따라 신뢰성 있는 전송을 제공하는 측에서 해야하는 복잡도가 달라진다.

신뢰성 있는 전송을 논할때는 우리는 보통 양방향 통신에 대해 생각한다.

그렇지만 양방향 통신은 단방향 통신이 순서에 관계없이 여러번 일어나는 것 이라고 생각할 수 있으므로 단방향 통신을 먼저 생각해보자.

우리는 송신자, 수신자로 액션을 취하는 주체를 둘로 나눌 것이다.
그리고 이 주체가 어떤 상태에 있고, 상태가 어떤 조건에 따라 변하는지 규정할 것 이다.
이 때, 상태가 변하는 조건을 event 라고 하고, 상태가 변할 때 일어나는 행동을 action이라고 할 것이다.
이 때 고려할 점은 서로 메시지를 주고받기 전까지는 송신자와 수신자가 서로의 상태를 모른다는 것이다.

이 조건을 따라 점진적으로 신뢰성 있는 전송 프로토콜(reliable data transfer protocol, rdt) 를 발전시켜나가보자.

**rdt 1.0**
rdt 1.0 에서는 우리가 데이터 전송에 사용하는 채널이 어떠한 비트에러도 없고 패킷 손실도 없다고 가정한다.

이 때 송신자의 상태는 **데이터 전송 호출을 기다리는 것** 하나 뿐이다. 
이 상태에서 신뢰성 있게 데이터를 보내라는 메시지(이하 rdt_send)를 받으면, 이 데이터를 필요한 정보를 넣어 패킷으로 만든다. 이후 내가 사용하는 신뢰성 없는 채널에 이 패킷을 흘려주고(이하 udt_send) 다시 원래 상태로 돌아가 기다린다.

수신자의 상태도 하나 뿐이다. 
채널에서 **데이터가 왔다는 호출을 해주기 기다리는 것** 이다.

만약 이 상태에서 신뢰성 있게 데이터를 받으라는 메시지(이하 rdt_rcv) 를 받으면 이 패킷의 데이터를 추출해 위 단계로 전달해준다(이하 deliver_data).

**rdt 2.0**
이제는 우리가 사용하는 채널이 패킷에 비트 에러를 발생시킨다고 가정하자.
우리는 채널을 지나는 동안 발생한 비트 에러를 어떻게 복구할까?

바로, 수신자의 수신 확인 메시지를 확인함으로 가능하다.

이를 위해 rdt2.0에서 송신자는 데이터 전송 한 가지 상태가 추가된다.
rdt_send 를 호출하고 난 후 송신자는 이 상태로 전이된다.

이 상태에서 수신자가 올바르게 데이터를 받았다는 신호를 전송하면 송신자는 다시 초기 상태로 돌아간다.

만약 그렇지 않다면 데이터를 재전송하고 원래 상태를 유지한다.

수신자는 상태는 동일하지만 두가지 event를 갖게 된다.

데이터가 왔을 때 패킷에 오류가 있다면 잘 받지 못했다는 NAK 신호를 보낸다.
반대로 잘 받았다면 deliver_data를 수행하고, ACK 신호를 보낸다.

여기에는 한 가지 오점이 있다.

만약 ACK, NAK가 똑바로 수신되지 않는다면 어떨까?
이럴경우 가장 심플하게 생각할 수 있는 송신자측의 행동은 재전송이다.
하지만 무조건 재전송하게 되면 수신자측에서는 중복되는 데이터를 받을 수 있다. 

이를 방지하기 위해 rdt 2.1 에서는 패킷에 id를 0,1로 붙인다.

**rdt 2.1**
여기서 우리는 패킷 id 0, 1 에 따라 송신자, 수신자의 상태를 rdt2.0으로부터 복사할 수 있다.
즉 송신자는 4개의 상태, 수신자는 2개의 상태를 갖게 된다.

만약 0번 패킷을 보내고 0번 패킷 수신 확인 단계에 있다면 0번 패킷 수신 확인 신호가 손실 없이 올 때 까지 1번 패킷을 보내지 않는다.

1번 패킷을 보낼 때도 마찬가지이다.

수신자측에서도 0번 패킷을 받게되면 1번 패킷만 기다리는 상태로 전환된다. 이 상태에서 0번 패킷이 다시 전송된다면 수신자 측은 이를 위로 올려보내지 않고 ACK 패킷만 재전송한다. 상태도 변하지 않는다.

참고로 rdt2.1 에서 id는 2개면 충분하다. 
0번이 완료될 때 까지 그 다음 0은 전송되지 않기때문.

**rdt2.2**
실제 TCP 에서는 NAK 신호가  없다.
이를 NAK-Free 라고 하는데, 이 때 NAK 대신 수신자는 고의적으로 잘못된 id의 NAK를 보내게 되고 이로인해 FSM이 더 간단하게 표현된다.

**rdt 3.0**
우리가 사용하는 채널이 패킷 손실을 일으킨다고 가정한다.
rdt3.0 에서 송신자는 패킷 발송 후 일정 시간을 기다리며 이 시간안에 ACK 가 오지 않을 경우 재전송한다.
만약 잘못된 ACK 신호(비트 에러, 혹은 시퀀스 번호 오류)가 수신될 경우는 무시한다.(타임 아웃까지 대기)
