
소련의 디니츠라는 학생이 AVL트리를 만든 교수에게 수업을 듣다가 생각해낸 알고리즘이다.
포드-풀커슨 알고리즘을 알지 못했던 디니츠는 최대 유량을 어떻게 계산할까 고민하다가 이 알고리즘의 베이스를 생각하게 됐다고 한다.(ㅎㄷㄷ..)

기본적인 디니츠 알고리즘의 골자는 다음과 같다.

1. 시작점부터 거리를 잔여 네트워크 안의 모든 정점에 대해 계산하고 저장한다. 
	- 시작점으로부터 거리의 차가 1인 인접한 정점만 따라 도착점까지 가게되면 최대 거리는 $|V|$  -1 이 된다. (즉 augment path이다.)
	- 만약 거리를 계산할 때 도착점에 도착하지 못하면 알고리즘을 종료한다.
2. 위의 거리를 통해 최단 증가 경로 $P$ 로 계속해서 유량을 흘려낸다.
	- dfs를 통해 시작점 ~ 도착점까지 흐르는 용량을 계속해서 계산해준다.
	- 이 과정에서 한 번 도착점에 도달할 때 마다 최대 $|V|$ - 1 개의 정점을 통과하고, 최소 1개의 병목 간선이 사라지므로 $O(|V||E|)$ 안에 수행할 수 있다.
	- 더 이상 증가 경로가 없을 경우 다시 1번으로 돌아간다.

매 증가 경로마다 2번이 반복되는 셈인데, 증가 경로의 최대 길이는 $|V|$ - 1 을 초과할 수 없다. 즉, 디니츠 알고리즘에서는 2번 루틴을 최대 $|V|$번 반복한다. 

2번 루틴의 시간 복잡도는 $O(|V||E|)$ -> 전체 알고리즘의 시간 복잡도는 $O(|V|^2|E|)$ 가 된다.

---

 1번 루틴의 코드이다.

```cpp
bool bfs() {  
    memset(lv, -1, sizeof(lv));  
    queue<int> q;  
    q.push(s);  
    lv[s] = 0;  
    while (!q.empty()) {  
        int x = q.front();  
        q.pop();  
        if (x == t) return true;
        for (auto e: g[x]) {  
            if (lv[e->to] == -1 && e->remain() > 0) {  
                lv[e->to] = lv[x] + 1;  
                q.push(e->to);  
            }  
        }  
    }  
    return lv[t] != -1;  
}
```


`lv[i]` 배열은 시작점으로부터 `i` 번째 정점이 현재 플로우 $f$ 의 증가 경로 상에서 몇의 거리를 가리키는지 저장한다.

bfs이므로 항상 `lv[i]` 가 낮은 정점부터 탐색하게 되므로 아직 거리가 갱신되지 않았고, 유량을 흘릴 용량이 남아있는 경우 현재 정점의 `lv + 1` 로 `lv` 를 갱신한다.

만약 최종 정점에 도착하지 못한다면 false를 반환한다. (더 이상 증가 경로가 없음)

---

2번 루틴의 코드는 다음과 같다.

```cpp
int dfs(int cur, int f) {  
    if (cur == t) return f;  
    for (int &i = work[cur]; i < g[cur].size(); ++i) {  
        Edge *e = g[cur][i];  
        if (lv[e->to] == lv[cur] + 1 && e->remain() > 0) {  
            int flow = dfs(e->to, min(f, e->remain()));  
            if (flow > 0) {  
                e->add_flow(flow);  
                return flow;  
            }  
        }  
    }  
    return 0;  
}
```

현재 정점의 모든 간선을 탐색하는데, 이 때 해당 간선으로 이어진 정점과의 거리가 1이고, 유량을 흘릴 수 있는 간선만 고려한다. 
t(SINK) 에 도착하면 현재 플로우를 차례로 return하며, 스택에 쌓여있는(경로에 포함된) 모든 간선의 flow를 갱신해준다.

여기서 work 배열은 막다른 길에 이르른 정점으로 가는 간선을 한 번만 선택하도록 도와줍니다.
현재 정점이 flow > 0 을 만나 리턴한 경우는 work 배열이 갱신되지 않기 때문에, 해당 간선에 대해서는 한번 더 고려할 수 있습니다.
반면, 한 번 탐색했는데 flow가 0인 결과가 나왔다면 조건문의 코드블록 `(++i)` 을 실행하여 현재 정점의 work 배열을 갱신한다. 다음에 이 정점을 탐색할 때에는 flow가 갱신될 가능성이 있는 간선만 탐색하게 된다.

---

이 둘을 합치면 다음과 같은 코드를 작성할 수 있다.

```cpp
int max_flow() {  
    int ret = 0;  
    while (bfs()) {  
        int f;  
        memset(work, 0, sizeof(work));  
        while ((f = dfs(s, 1e9)) > 0) {  
            ret += f;  
        }  
    }  
    return ret;  
}
```

1번 루틴을 반복하며 계속하여 증가경로에 있는 정점들의 시작점으로부터 거리를 갱신한다.

찾아진 증가 경로를 통해 플로우를 흘리는 것을 2번 루틴을 통해 반복한다. 만약, 플로우가 0이 반환된다면 해당 경로로는 더 이상 플로우를 흘릴 수 없다는 것을 의미한다.

위를 반복하다가 더 이상 증가경로를 찾을 수 없을 때 알고리즘을 종료한다.