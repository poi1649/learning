
- 리드 어헤드란?
    
    - 디스크에서 페이지를 읽어올 때 연속된 많은 페이지를 읽어오면 성능점으로 이점이 있을 수 있다. 이노디비에서는 여러 페이지를 한번에 읽어오는데 이를 리드 어헤드라고 한다.
    - 리드 어헤드는 백그라운드 스레드가 담당한다.
    - 처음에는 포그라운드 스레드가 페이지를 읽는데, 일정 페이지 값 이상 읽게 되면 리드 어헤드가 실행된다.
- PK를 설정하지 않으면 어떻게 될까?
    
    - InnoDB 기준, 가상의 인덱스 컬럼을 만든다. 대체되는 auto-increment 키를 만들지만, 실제로 보이지는 않는다. 그렇기 때문에 내부적으로는 pk를 대체하지만 사용자가 직접 사용할 수는 없다.
- PK를 직접 사용해야 하는 이유
    
    - 어차피 PK가 생성된다면 내가 비즈니스적인 의미를 담아 지정하는 것이 좋다고 생각한다. PK가 있어야 복제도 유효하게 될 수 있다.
- 클러스터링 인덱스 사용할 때와 사용하지 않을 때 장단점
    
    - 클러스터링 인덱스는 리프노드가 실제 데이터이기에 데이터가 정렬이 되어 있다.
    - 클러스터링 인덱스는 레코드를 묶어서 저장하는 것. 단점은 실제 레코드의 위치가 변경된다. 세컨더리 인덱스는 쉽게 변경할 수 있다. 대신 조회할 때는 조금 더 빠르다.
- 레코드 정렬 알고리즘의 두 가지 모드
    
    - 투패쓰
        - 소트 버퍼에 프라이머리 + 정렬하고자 하는 컬럼 값만 넣고 정렬
        - 정렬 결과를 레코드로 다시 한 번 변환해야해서 오버헤드가 있다.
    - 싱글패쓰
        - 소트 버퍼에 레코드 전체를 넣고 정렬
        - 디스크 IO가 한번이기 때문에 빠르다
- 투패쓰는 언제 사용될까?
    
    - 레코드의 크기가 시스템 변수에 설정된 값보다 클 때
- select * from employee where id < 300 어떤 인덱스 스캔 방식을 쓸까?
    
    - 인덱스 레인지 스캔일 것 같다.
- 그렇다면 * 가 문제가 되지 않을까?
    
    > 레코드에만 있는 칼럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 한다
    
    - 책에서 위와 같이 설명하고 있다.
        - 책에서 설명할 때의 쿼리는 id에 대한 where 절이 없다.
    - 에밀이 제시한 where 절이 들어간 쿼리는 id가 있기 때문에 레인지 스캔을 한다.
- 소트 버퍼란?
    
    - MySQL 엔진에서 사용하는 로컬 메모리 공간.
    - 정렬이 사용할 때만 메모리를 할당 받았다가 정렬이 끝나면 메모리를 반납하는 특성
    - 함수로 인해 컬럼이 변형될 경우, 따로 정렬이 필요하기 때문에 해당 정렬을 위한 공간
- 정렬 해야 할 레코드 건 수가 소트 버퍼의 크기보다 크다면?
    
    - 디스크를 임시 공간으로 사용한다.
    - 일부를 소트 버퍼에서 정렬해서 임시 공간에 넣고, 이어서 일부를 소트 버퍼에서 정렬한 뒤 머지하는 과정을 반복한다. == 멀티 머지
- Extra 칼럼에 들어가는 값에 무엇이 있지?
    
    - Using Temporary → 드라이빙 테이블과 드리븐 테이블을 합해서 정렬해야할 때 임시 테이블을 사용할 때 나타난다.
    - Using Filesort → 인덱스를 사용하는 경우 말고 드라이빙 테이블만 정렬할 때 Filesort가 사용된다.
- 정렬 쿼리가 사용되는 방식 두 가지
    
    - 버퍼링
        - 데이터가 너무 클 때, IO 병목등이 일어날 수 있음
    - 스트리밍
        - 조건에 맞는 데이터가 있을 때 마다 데이터 스트림을 계속해서 전송
        - 웹서비스 같은 OLTP 환경에서 사용되면 좋음
- Using Temporary 시점
    
    - 기본적으로 인덱스가 없는 컬럼에 대해서 정렬할 때, 드리븐 테이블에 대한 정렬이 필요할 때입니다.
    - 드라이빙 테이블만으로는 정렬을 수행할 수 없을 때
    - **드리븐 테이블의 컬럼이 정렬의 기준으로 사용될 때**