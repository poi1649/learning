
### MRR(Multi-Range Read)

- 이전 버전의 MySQL은 조인을 수행할 때, 드라이빙 테이블의 레코드를 1건 찾고 이에 맞는 드리븐 테이블의 레코드를 다시 찾아 조인을 바로 수행하는 방식을 선택했다. 이를 `Nested Loop Join` 이라고 한다.

- 이렇게 레코드를 건 별로 읽으라고 MySQL 엔진이 스토리지 엔진에게 요청을 보낼 경우 스토리지 엔진은 아무런 최적화도 수행할 수 없다.

- 이와 같은 단점을 보완하기 위해 MySQL의 새로운 버전에서는 조인 버퍼에 드라이빙 테이블의 레코드를 버퍼링하고, 이 버퍼가 가득 차면 그 때 스토리지 엔진에게 드리븐 테이블의 레코드를 찾도록 요청을 보낸다. 이 방식을 MRR 이라고 한다.

- 이 방법을 사용하는 조인을 BKA(Batched Key Access) 조인이라고 하는데, 찾아온 레코드들에 대해서 일련의 정렬 과정이 필요하기 때문에 단점도 있다. 


### Block nested loop join

- MySQL에서는 대부분 Nested Loop Join 을 사용한다. (조인을 연결하는 칼럼에 전부 인덱스가 걸려있을 경우 사용된다.)

- 만약 조인을 연결하는 칼럼에 어떠한 인덱스 힌트도 없다면 데카르트 곱을 가져올 수도 있다.

- 이를 방지하기 위해 MySQL엔진에서는 조인 버퍼에 드라이빙 테이블의 레코드를 먼저 담아놓고, 드리븐테이블의 레코드를 따로 스캔해서 조인 후 반환하는 과정을 이용하는데 이를 Block nested loop join이라고 한다.

- 조인의 순서, 결과의 정렬이 흐트러질 수 있다.

- MySQL 8.0.29 부터는 해시 조인 알고리즘이 대신 사용된다.


### Index condition push down

- MySQL 5.6 이후 버전부터는 인덱스 범위 제한 조건으로 사용하지 못하더라도 스토리지 엔진으로 해당 인덱스 조건을 전달할 수 있다.

- 이를 Index condition push down이라고 한다.

### use_index_extension

- InnoDB에서 세컨더리 인덱스는 실제 데이터 레코드를 찾기 위해 프라이머리 인덱스를 참조해야만 한다.

- 즉 내부적으로 (secondary index, primary index) 의 인덱스를 사용하는 것처럼 동작한다.

- 옵티마이저가 위 상황을 인지하고 실행 계획을 세울 때 숨어있는 primary index를 사용하게 되는데, 이를 use_index_extension이라고 한다.