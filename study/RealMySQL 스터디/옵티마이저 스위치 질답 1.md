
- MRR 이 뭔가요?
    - 조인을 할 때 조인 대상이 되는 레코드를 캐시해둬서 한 번에 데이터를 요청하는 방식
    - MRR의 주체와 대상
        - Mysql 엔진, 스토리지 엔진
    - 장점, 단점
        - IO가 줄어든다.
        - 여러건을 한 번에 읽어오는 만큼 스토리지 엔진의 최적화가 가능하다.
        - 조인 버퍼에 쓰이는 공간이 단점이 된다.
        - 조인을 할 때 정렬 작업이 추가로 들어간다.
        - 조인을 할 때 정렬이 되지 않는다.
- Nested Loop join?
    - 드라이빙 테이블 레코드 한 건단 드리븐 테이블 레코드를 읽어오고 조인을 하는 방법
    - block nested loop join과의 차이 ⇒
        - 조인하는 컬럼에 인덱스가 걸려 있지 않다. 이때 풀 테이블 스캔을 해야 하는데, 이는 비효율적이기 때문에 버퍼에 담아 놓고, 그 후에 조인 대상 테이블과 조인한다.
    - MRR: 조인 버퍼에 가져온다. 그리고 드라이빙 테이블의 id로 드리븐 테이블을 모두 조회한다.
    - MRR과 block nested loop join과의 차이는 조인하는 컬럼에 인덱스가 걸려 있는지 여부
- MRR은 어떤 단점을 극복한 것일까?
    - 디스크 쓰기 - 레코드를 한 건씩 읽어옴으로써 발생하는 문제를 극복했다.
- 인덱스 컨디션 푸시 다운이 어떤 문제에서 발생했을까??
    - (InnoDB 기준) 세컨더리 인덱스는 모두 클러스터링 키의 값을 리프 노드에 가지고 있다. 그렇기 때문에 세컨더리 인덱스는 어쨌든 클러스터링 키를 통해 실제 데이터를 찾는다.
    - 어차피 세컨더리 인덱스를 사용하려면 클러스터링 키를 포함해야 한다. 이를 이용해서 세컨더리 인덱스를 활용할 때 클러스터링 키도 활용할 수 있도록 한다. 이를 인덱스 푸시 다운이라고 한다.